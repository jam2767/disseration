Tree ring bayesian hierarchical mixed effects model
========================================================

The tree ring analysis to-date has included a hierarchical structure to include individuals, subplots, plots and sites and some individual effects like species. I am now adding year x plot and year x site interactions to see how much variance is explained by climate at each site and within a site.

You can embed an R code chunk like this:

```{r}
#Required Packages
library(rjags)
library(data.table)

#Source required PEcAn scripts for reading and matching treerings and plot data
source("/Users/Josh/Documents/Research/pecan/modules/data.land/R/Read_Tuscon.R")
source("/Users/Josh/Documents/Research/pecan/modules/data.land/R/matchInventoryRings.R")
```

Using most up-to-date version of adult census data for treering matching. Includes 2015 census data, but not boolean damage column. All other columns should be the same as analysis done for AGU and EE seminar.

```{r}
#read Tucson format ringwidth files
trees.diss <- read.csv("/Users/josh/Dropbox/Dissertation/CH1_Treerings/Data/Adult_Field_Data_JAM_MCD.csv")
rings.diss <- Read_Tuscon("/Users/josh/Dropbox/Dissertation/CH1_Treerings/Data/Windendro_Dissertation")

#Match Tucson ringwidth files and adult census data for 50yrs of growth
combined.diss <- matchInventoryRings(trees=trees.diss,rings.diss)
#combined.diss <- data.frame(combined.diss)
# write.csv(combined.diss, file="/Users/josh/Dropbox/Dissertation/CH1_Treerings/Data/combined.diss.csv")
#TODO correct cores with known suspiciously large growth increment
#cores ID'd in /Users/josh/Dropbox/Dissertation/CH1_Treerings/Data/qc_removed_cores.xlsx

#write file to check which cores still need to be analyzed
#common sample ID to match with
combined.diss$sampleID <- mapply(combined.diss$SITE, combined.diss$PLOT, combined.diss$SUB, combined.diss$TAG, FUN = paste0)

trees.diss$sampleID <- mapply(trees.diss$Site, trees.diss$Plot, trees.diss$Sub, trees.diss$Tag, FUN = paste0)

analyzed.trees.growth <- merge(combined.diss, trees.diss, by = "sampleID", all.x = TRUE, all.y = TRUE)
check.growth.analyzed <- cbind(analyzed.trees.growth[,1:9],analyzed.trees.growth[,131:139],analyzed.trees.growth[,144:151],analyzed.trees.growth[,208],analyzed.trees.growth[,223])
names(check.growth.analyzed)[27] <- "DBH14"
names(check.growth.analyzed)[28] <- "DBH15"
write.csv(check.growth.analyzed, file = "alltrees_growth_analyzed_tracking_CDincluded.csv")

```
Reformat combined census and treering data dataframe to comply with format required for including time explicitly, which includes year by site and year by plot interaction terms.
```{r}
####didn't need to do all of this####
# #recreate data frame to be compliant with structure needed to include time as a variable (50 years)
# ids.rep.new.diss <- data.frame(matrix(NA,nrow=1,ncol=92))                    
# colnames(ids.rep.new.diss) <- colnames(combined.diss[1:92])
# for(i in 1:nrow(combined.diss)){
#   ids.rep.diss <- combined.diss[rep(i,times=50),1:92]
#   ids.rep.new.diss <- rbind(ids.rep.new.diss,ids.rep.diss)
# }
# #remove row of NAs
# combined.ids.diss <- ids.rep.new.diss[2:nrow(ids.rep.new.diss),]
# 
# #transpose and concatenate increments for all trees
# inc.new.diss <- vector("numeric",length=0)
# for(i in 1:nrow(combined.diss)){
#   inc.diss <- as.matrix(combined.diss[i,93:142])
#   inc.new.diss <- as.numeric(c(inc.new.diss,inc.diss))
# }
# 
# #add ring increments
# combined.ids.incs.diss <- cbind(combined.ids.diss,inc.new.diss)
# 
# #rename inc variable
# setnames(combined.ids.incs.diss,old='inc.new.diss',new='INCREMENT')
# 
# YEAR <- seq(1964,2013,1)
# YEAR <- rep(YEAR,1415)
# 
# #final version with 50yrs of growth
# combined.all.diss <- cbind(combined.ids.incs.diss,YEAR)
```

```{r}
#JAGS Bayesian Hierarchical linear model 
#Hierarchical terms for JAGS
ringwidths <- combined.diss[97:136]
s<-as.numeric(as.factor(as.character(combined.diss$SITE)))
p<-as.numeric(as.factor(paste0(as.character(combined.diss$SITE),
                               as.character(combined.diss$PLOT))))
sp <- as.numeric(as.factor(paste0(as.character(combined.diss$SITE),
                                  as.character(combined.diss$PLOT),
                                  as.character(combined.diss$SUB))))
#creating interaction terms for JAGS
#Site by Year interaction, n = 400, 8 sites, 50 years each
#sy <- as.numeric(as.factor(paste0(as.character(combined.diss$SITE),
                                  #colnames(combined.diss[93:142]))))
# #Plot by Year interaction, n = 2600, 8 sites, 6-7 plots each
# spy <- as.numeric(as.factor(paste0(as.character(combined.diss$SITE),
#                                   as.character(combined.diss$PLOT),
#                                   colnames(combined.diss[93:142]))))

#x = 1/var(combined.diss$INCREMENT,na.rm=TRUE) #precision on all years
#y = mean(combined.diss$INCREMENT,na.rm=TRUE) #mean all years
x = 1/var(as.vector(as.matrix(ringwidths)),na.rm=TRUE)
y = mean(as.matrix(ringwidths),na.rm=TRUE) ## overall mean growth rate
mean40yr = rowMeans(ringwidths,na.rm=TRUE) #means by individual
column.means = colMeans(ringwidths,na.rm=TRUE) #means by year
us = tapply(X=mean40yr,INDEX=list(s),FUN=mean,na.rm=TRUE)
up = tapply(X=mean40yr,INDEX=list(p),FUN=mean,na.rm=TRUE)
usp = tapply(X=mean40yr,INDEX=list(sp),FUN=mean,na.rm=TRUE)
#usy = tapply(X=mean50yr,INDEX=list(sy),FUN=mean,na.rm=TRUE)
usy = apply(ringwidths,2,function(x1){tapply(x1,s,FUN=mean,na.rm=TRUE)})
usy[is.nan(usy)] = 0
ty = 1/var(column.means)
ts = 1/var(us)
tp= 1/var(up)
tsp= 1/var(usp)
tsy= mean(1/var(usy))
as = us - mean(us)
ap = up - mean(up) 
asp= usp - mean(usp)
ai = mean40yr - mean(y)
ay = column.means - mean(column.means)

data2 = list(x=as.matrix(combined.diss[,93:142]), nyear=40, 
             nrep = 1590,s=s,p=p,sp=sp,ns=max(s),np = max(p),nsp=max(sp))

asy = apply(data2$x,2,function(x){tapply(x,s,function(w){mean(w-y,na.rm=TRUE)})})
asy[is.nan(asy)]  = 0

init = list(mu = y,prec = x,tau.y = ty,tau.s = ts,tau.p = tp,tau.sp = tsp,
            tau.sy = tsy,tau.ind = x,alpha.site = as,alpha.plot = ap,
            alpha.sub = asp,alpha.siteyear = asy,alpha.ind = ai,alpha.y = ay)

FitRand.SiteYear = "
model {
mu ~ dnorm(0,0.001)
prec ~ dgamma(0.1,0.1)
tau.y ~ dgamma(0.1,0.1)  #prior year-effect
tau.s ~ dgamma(0.1,0.1)  #prior site
tau.p ~ dgamma(0.1,0.1)  #prior plot
tau.sp ~ dgamma(0.1,0.1) #prior subplot
tau.ind ~ dgamma(0.1,0.1) #prior individual
tau.sy ~ dgamma(0.1,0.1) #prior site x year effect
#tau.spy ~ dgamma(0.1,0.1) #prior plot x year effect

for(s in 1:ns){
  alpha.site[s] ~ dnorm(0,tau.s)
  for(y in 1:nyear){
    alpha.siteyear[s,y] ~ dnorm(0,tau.sy)
  }
}
for(p in 1:np){
alpha.plot[p] ~ dnorm(0,tau.p)
}
for(sp in 1:nsp){
alpha.sub[sp] ~ dnorm(0,tau.sp)
}
for(i in 1:nrep){
alpha.ind[i] ~ dnorm(0,tau.ind)
}

for(y in 1:nyear){
alpha.y[y] ~dnorm(0,tau.y)
for(i in 1:nrep){
Ex[i,y] <- mu + alpha.y[y]  + alpha.site[s[i]] + alpha.plot[p[i]] + alpha.sub[sp[i]] + alpha.ind[i] + alpha.siteyear[s[i],y]

x[i,y] ~dnorm(Ex[i,y],prec)
}
}
}"

## compile JAGS model
j.model   <- jags.model (file = textConnection(FitRand.SiteYear),
                         data = data2,
                         inits = init,
                         n.chains = 3)
## burn-in
b   <- coda.samples (model = j.model,
                      variable.names = c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind","tau.sy"),
                      n.iter = 50,
                      thin = 2)

# bt   <- coda.samples (model = j.model,
#                      variable.names = c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),
#                      n.iter = 5000)

update.jags<-function(model,previous.coda,variable.names,iter){
  samp <- coda.samples (model = model,
                        variable.names = variable.names,
                        n.iter = iter,
                        thin=2)
  new.list <- list()
  for(i in 1:length(samp)){
    new.list[[i]] = as.mcmc(rbind(previous.coda[[i]],samp[[i]]))
  }
  bmcmc <<- mcmc.list(new.list)
  #return(bmcmc)
}

update.jags(j.model,b,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind","tau.sy"),500)
# b1<- coda.samples (model = j.model,
#                    variable.names = c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),#,"alpha.y","alpha.site","alpha.plot","alpha.sub"),#,"alpha.ind"),
#                    n.iter = 100)#,

b.out<-b
bmcmc1<-bmcmc
# update.jags(j.model,bmcmc1,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),1000)
# bmcmc2<-bmcmc
# update.jags(j.model,bmcmc2,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),2000)
# bmcmc3<-bmcmc
# update.jags(j.model,bmcmc3,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),1000)
# bmcmc4<-bmcmc
# update.jags(j.model,bmcmc4,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),10000)
# bmcmc5<-bmcmc
# update.jags(j.model,bmcmc5,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),20000)
# bmcmc6<-bmcmc
# update.jags(j.model,bmcmc6,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),20000)
# bmcmc7<-bmcmc
# update.jags(j.model,bmcmc7,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),10000)
# bmcmc8<-bmcmc
# update.jags(j.model,bmcmc8,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),20000)
# bmcmc9<-bmcmc

#transform posteriors to standard deviations
test.sd2 <- list()
test.sd2 <- for(i in 1:3){
  test.sd2[[i]]<-as.mcmc(sqrt(1/bmcmc1[[i]]))

  test.SD <- mcmc.list(test.sd2)
}

for(i in 1:8){
  plot(test.SD[,i],cex.lab=1.8,xlim=c(0,1.25))
}

str(summary(bmcmc1))
#for(i in 1:7){
  summary(bmcmc1)#[,i])    ## summary table
#}

for(i in 1:8){
  plot(bmcmc1[,i])
  #plot(sqrt(1/(bmcmc9[,i]))) ## mcmc trace and density plots
}

# for(i in 1:7){
#   plot(bmcmc7[,i]) ## mcmc trace and density plots
# }
# 
# for(i in 1:7){
#   plot(bmcmc6[,i]) ## mcmc trace and density plots
# }
# 
# for(i in 1:7){
#   plot(bmcmc5[,i]) ## mcmc trace and density plots
# }
# for(i in 1:7){
#   plot(bmcmc3[,i]) ## mcmc trace and density plots
# }
# #bmcmc is new output
# for(i in 1:7){
#   plot(bmcmc2[,i]) ## mcmc trace and density plots
# }
# for(i in 1:7){
#   plot(b.out[,i]) ## mcmc trace and density plots
# }
for(i in 1:8){
autocorr.plot(b.out[,i]) ## autocorrelation
}
for(i in 1:8){
cumuplot(b.out[,i]) ## quantile plot
}
for(i in 1:8){
gelman.plot(b.out[,i])      ## GRB statistic
}
for(i in 1:8){
summary(b.out[,i])    ## summary table
}

##### done visualizing outputs #####

update.jags<-function(model,previous.coda,variable.names,iter){
  samp <- coda.samples (model = model,
                variable.names = variable.names,
                n.iter = iter)
  bmcmc <<- mcmc(do.call(rbind,c(previous.coda,samp)))
  #return(bmcmc)
}

update.jags(j.model,b,c("mu","prec","tau.y","tau.s","tau.p","tau.sp","tau.ind"),100)
# b3 <- coda.samples (model = j.model,
#                     variable.names = c("mu","prec"),#,"alpha.y","alpha.site","alpha.plot","alpha.sub"),#,"alpha.ind"),
#                     n.iter = 500)#,
# update.jags(model=j.model,previous.coda=b3,variable.names=c("mu","prec"),iter=500)

# bmcmc3 = b3
# plot(bmcmc3)



mu2 = as.data.frame(as.matrix(bmcmc2))$mu
quantile(mu2,c(0.025,0.5,0.975))







# #just look at AGU code for example of how to make unique IDs
# #Example creating interaction term
# Y = seq(1,10)
# L = as.vector(x=c("A","B","C"))
# YL = expand.grid(Y,L) #creates matrix of all combinations as characters
# YL.vector = as.vector(paste0(YL$Var1,YL$Var2)) #vector of all combinations as characters
# #Can now use this to create interaction term for years x plot and years x site

```

You can also embed plots, for example:

```{r fig.width=7, fig.height=6}
plot(cars)
```


